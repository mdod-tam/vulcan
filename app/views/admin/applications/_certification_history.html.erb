<%
  # Use application instance variable to avoid repeating queries
  request_count = @application.medical_certification_request_count || 0
  
  # Only load events if we haven't already done so in the controller
  # This ensures we don't duplicate expensive queries
  if !defined?(@certification_events) || @certification_events.nil?
    # Get certification events from multiple sources
    notifications = Notification.includes(:actor)
                      .where(notifiable: @application)
                      # Include all certification-related actions
                      .where("action LIKE ?", "%certification%")
                      .select(:id, :actor_id, :action, :created_at, :metadata, :notifiable_id)
    
    # Get status changes related to medical certification
    status_changes = ApplicationStatusChange.where(application_id: @application.id)
                      .where("metadata->>'change_type' = ? OR from_status LIKE ? OR to_status LIKE ?", 
                            'medical_certification', '%certification%', '%certification%')
                      .includes(:user)
                      .select(:id, :user_id, :from_status, :to_status, :created_at, :metadata)
    
    # Get events related to medical certification - broader match
    events = Event.where("(metadata->>'application_id' = ? AND (action LIKE ? OR metadata::text LIKE ?))", 
                        @application.id.to_s, 
                        "%certification%",
                        "%certification%")
                  .includes(:user)
                  .select(:id, :user_id, :action, :created_at, :metadata)
    
    # Rails.logger.debug("CERTIFICATION HISTORY: #{notifications.length} notifications, #{status_changes.length} status changes, #{events.length} events")
    
    # Combine all events and sort by creation date
    raw_events = (notifications.to_a + status_changes.to_a + events.to_a)
                  .sort_by(&:created_at)
                  .reverse
                  .first(20) # Increase limit to ensure we catch all duplicates
    
    # Deduplicate events based on timestamp and action type
    # Create a hash for event deduplication with composite keys
    events_by_key = {}
    
    raw_events.each do |event|
      # Extract timestamp
      timestamp = event.created_at
      if event.respond_to?(:metadata) && event.metadata.is_a?(Hash) && event.metadata['timestamp'].present?
        begin
          timestamp = Time.parse(event.metadata['timestamp'])
        rescue
          # Keep the original timestamp if parsing fails
        end
      end
      
      # Determine event type
      if event.is_a?(Notification)
        event_type = event.action
        actor_name = event.actor&.full_name || "System"
        provider_name = event.metadata.is_a?(Hash) ? event.metadata['provider_name'] : nil
      elsif event.is_a?(ApplicationStatusChange)
        event_type = event.to_status
        actor_name = event.user&.full_name || "System"
        provider_name = event.metadata.is_a?(Hash) ? event.metadata['provider_name'] : nil
      elsif event.is_a?(Event)
        event_type = event.action
        actor_name = event.user&.full_name || "System"
        provider_name = event.metadata.is_a?(Hash) ? (event.metadata["provider_name"] || event.metadata["doctor_name"]) : nil
      end
      
      # Create a unique key for this event type based on time and provider
      # Round timestamp to the minute to handle slight time differences
      timestamp_key = timestamp.strftime("%Y-%m-%d %H:%M")
      uniq_key = "#{timestamp_key}||#{event_type}||#{provider_name}"
      
      # Prioritize events with more information
      if !events_by_key.key?(uniq_key) || 
         (event.respond_to?(:metadata) && event.metadata.present? && events_by_key[uniq_key].respond_to?(:metadata) && !events_by_key[uniq_key].metadata.present?) ||
         (provider_name.present? && !events_by_key[uniq_key].respond_to?(:metadata))
        events_by_key[uniq_key] = event
      end
    end
    
    # Convert back to array and sort
    @certification_events = events_by_key.values.sort_by(&:created_at).reverse
  end
  
  # Determine which events are requests (for numbering)
  is_request_event = {}
  @certification_events.each do |event|
    is_request = (event.is_a?(Notification) && event.action == "medical_certification_requested") ||
                 (event.is_a?(ApplicationStatusChange) && event.to_status == "requested") ||
                 (event.is_a?(Event) && (event.action == "medical_certification_requested" || 
                                       (event.metadata.is_a?(Hash) && 
                                        event.metadata['details'].to_s.include?('certification requested')))) ||
                 (event.respond_to?(:metadata) && 
                  event.metadata.is_a?(Hash) && 
                  event.metadata.to_s.include?('certification requested'))
                  
    is_request_event[event.id] = is_request
  end
  
  # Count the actual number of request events after deduplication
  request_events = @certification_events.select { |event| is_request_event[event.id] }
  
  # Set the total count to at least match the existing count from application
  total_requests = [request_events.size, request_count].max
  
  # Pre-calculate the request numbers with proper sequential numbering
  request_indexes = {}
  current_index = 0
  
  # Assign sequential numbers to request events
  @certification_events.each do |event|
    if is_request_event[event.id]
      # Make sure we never have a request number less than 1
      request_indexes[event.id] = [total_requests - current_index, 1].max
      current_index += 1
    end
  end
%>

<div class="certification-history mt-2 pl-4 border-l-2 border-gray-200">
  <% if @certification_events.any? %>
    <% @certification_events.each_with_index do |event, index| %>
      <% 
        # Get timestamp and determine event type based on event class
        timestamp = event.created_at
        if event.respond_to?(:metadata) && event.metadata.is_a?(Hash) && event.metadata['timestamp'].present?
          begin
            timestamp = Time.parse(event.metadata['timestamp'])
          rescue
            # Keep the original timestamp if parsing fails
          end
        end
        
        # Determine event type and details based on record type - more inclusive detection
        if event.is_a?(Notification)
          is_request = event.action == "medical_certification_requested" || 
                      event.action.to_s.include?("certification") && event.action.to_s.include?("request")
          is_rejection = event.action == "medical_certification_rejected" || 
                        event.action.to_s.include?("certification") && event.action.to_s.include?("reject")
          request_number = request_indexes[event.id] if is_request
          actor_name = event.actor&.full_name || "System"
        elsif event.is_a?(ApplicationStatusChange)
          is_request = event.to_status == "requested" || 
                      (event.metadata.is_a?(Hash) && event.metadata["change_type"] == "medical_certification" && 
                       event.to_status.to_s.include?("request"))
          is_rejection = event.to_status == "rejected" || 
                        (event.metadata.is_a?(Hash) && event.metadata["change_type"] == "medical_certification" && 
                         event.to_status.to_s.include?("reject"))
          request_number = request_indexes[event.id] if is_request
          actor_name = event.user&.full_name || "System"
        elsif event.is_a?(Event)
          is_request = event.action == "medical_certification_requested" || 
                      event.action.to_s.include?("certification") && event.action.to_s.include?("request") ||
                      (event.metadata.is_a?(Hash) && event.metadata["details"].to_s.include?("certification requested"))
          is_rejection = event.action == "medical_certification_rejected" || 
                        event.action.to_s.include?("certification") && event.action.to_s.include?("reject") ||
                        (event.metadata.is_a?(Hash) && event.metadata["details"].to_s.include?("certification rejected"))
          request_number = request_indexes[event.id] if is_request
          actor_name = event.user&.full_name || "System"
          
          # Try to extract provider name from event metadata if available
          provider_name = event.metadata.is_a?(Hash) ? (event.metadata["provider_name"] || event.metadata["doctor_name"]) : nil
        end
      %>
      <div class="request-item mb-2">
        <p class="text-sm <%= is_request ? 'text-gray-600' : (is_rejection ? 'text-red-600' : 'text-blue-600') %> mb-1">
          <% if is_request %>
            Request <%= request_number %> sent on 
            <%= timestamp.strftime("%B %d, %Y at %I:%M %p") %>
            <% if actor_name.present? %>by <%= actor_name %><% end %>
            <% if defined?(provider_name) && provider_name.present? %>
              to <%= provider_name %>
            <% elsif event.respond_to?(:metadata) && event.metadata.is_a?(Hash) && event.metadata['provider_name'].present? %>
              to <%= event.metadata['provider_name'] %>
            <% end %>
          <% elsif is_rejection %>
            Medical certification rejected on
            <%= timestamp.strftime("%B %d, %Y at %I:%M %p") %>
            <% if actor_name.present? %>by <%= actor_name %><% end %>
          <% elsif event.is_a?(ApplicationStatusChange) && event.to_status == "approved" %>
            Medical certification approved on
            <%= timestamp.strftime("%B %d, %Y at %I:%M %p") %>
            <% if actor_name.present? %>by <%= actor_name %><% end %>
          <% elsif event.is_a?(ApplicationStatusChange) && event.to_status == "received" %>
            Medical certification received on
            <%= timestamp.strftime("%B %d, %Y at %I:%M %p") %>
            <% submission_method = event.metadata['submission_method'] if event.respond_to?(:metadata) && event.metadata.is_a?(Hash) %>
            <% if submission_method.present? %>(via <%= submission_method %>)<% end %>
          <% end %>
          <% if index == 0 %>
            <span class="text-xs text-gray-500">(most recent)</span>
          <% end %>
        </p>
        
        <% 
          # Display rejection reason if available
          rejection_reason = nil
          if is_rejection
            if event.is_a?(ApplicationStatusChange) && event.metadata.is_a?(Hash) && event.metadata['rejection_reason'].present?
              rejection_reason = event.metadata['rejection_reason']
            elsif event.respond_to?(:metadata) && event.metadata.is_a?(Hash) && event.metadata['reason'].present?
              rejection_reason = event.metadata['reason']
            end
          end
        %>
        
        <% if rejection_reason.present? %>
          <p class="text-sm text-gray-600 ml-4 mb-1">
            <span class="text-gray-500">Reason:</span> <%= rejection_reason %>
          </p>
        <% end %>
      </div>
    <% end %>
  <% else %>
    <div class="request-item mb-2">
      <p class="text-sm text-gray-600 mb-1">
        <span class="text-yellow-500">Note:</span> No detailed request history available.
        <% if @application.medical_certification_requested_at.present? %>
          Last request sent on <%= @application.medical_certification_requested_at.strftime("%B %d, %Y at %I:%M %p") %>
        <% end %>
      </p>
    </div>
  <% end %>
</div>
