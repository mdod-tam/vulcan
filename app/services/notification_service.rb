# frozen_string_literal: true

# Centralized service for creating and delivering all notifications.
# This service is designed to be the single point of entry for any notification
# generated by the system, ensuring consistency in creation, delivery,
# error handling, and audit logging.
#
# Usage:
#   NotificationService.create_and_deliver!(
#     type: :proof_approved,
#     recipient: user,
#     actor: admin,
#     notifiable: application,
#     audit: true,
#     channel: :email,
#     metadata: { custom_key: 'value' }
#   )
#
class NotificationService
  class << self
    # Creates and delivers a notification in a single, robust step.
    #
    # @param type [Symbol] The action type of the notification (e.g., :proof_rejected).
    # @param recipient [User] The user who will receive the notification.
    # @param actor [User, nil] The user who initiated the action.
    # @param notifiable [ActiveRecord::Base, nil] The object associated with the notification.
    # @param deliver [Boolean] Whether to enqueue the notification for delivery.
    # @param audit [Boolean] Whether to create an Event record for the audit trail.
    # @param channel [Symbol] The delivery channel (:email, :sms, etc.).
    # @param options [Hash] Additional options, including :metadata.
    # @return [Notification, nil] The created Notification record, or nil on failure if errors are ignored.
    def create_and_deliver!(type:, recipient:, actor: nil, notifiable: nil, deliver: true, audit: false, channel: :email, **options)
      Rails.logger.info "Creating notification: #{type} for #{recipient.class.name}##{recipient.id} via #{channel}"

      notification = create_notification!(
        type: type,
        recipient: recipient,
        actor: actor,
        notifiable: notifiable,
        metadata: options.fetch(:metadata, {}).merge(
          created_by_service: true,
          timestamp: Time.current.iso8601,
          channel: channel.to_s
        ),
        audited: audit
      )

      log_to_audit_trail(notification) if audit
      deliver_notification!(notification, channel: channel, **options) if deliver

      notification
    rescue StandardError => e
      Rails.logger.error "NotificationService: Creation/Delivery failed for type '#{type}': #{e.message} \n #{e.backtrace.first(5).join("\n")}"
      # To prevent breaking critical user flows, we don't re-raise by default.
      # The error is logged, and delivery failure is handled in `handle_delivery_error`.
      # If a specific call site needs to fail hard, it can rescue and re-raise.
      nil
    end

    private

    def create_notification!(type:, recipient:, actor:, notifiable:, metadata:, audited:)
      Notification.create!(
        recipient: recipient,
        actor: actor,
        action: type.to_s,
        notifiable: notifiable,
        metadata: metadata,
        audited: audited
      )
    end

    def deliver_notification!(notification, channel:, **_options)
      case channel
      when :email
        mailer_class, method_name = resolve_mailer(notification)
        return unless mailer_class && method_name

        # Handle special case for account_created which expects (constituent, temp_password)
        if notification.action == 'account_created'
          temp_password = notification.metadata&.dig('temp_password')
          unless temp_password
            Rails.logger.error "NotificationService: account_created notification missing temp_password in metadata for Notification ##{notification.id}"
            return
          end
          mailer_class.public_send(method_name, notification.recipient, temp_password).deliver_later
        else
          # Pass the notifiable and the notification itself, as some mailers may need both.
          # The `proof_review` object is a good example of this pattern.
          mailer_class.public_send(method_name, notification.notifiable, notification).deliver_later
        end
      when :sms, :webhook
        Rails.logger.info "NotificationService: Delivery for channel '#{channel}' not yet implemented for Notification ##{notification.id}."
      else
        Rails.logger.warn "NotificationService: Unknown channel '#{channel}' for Notification ##{notification.id}."
      end
    rescue StandardError => e
      handle_delivery_error(notification, e, channel)
    end

    def resolve_mailer(notification)
      # Maps a notification action string to a mailer class and method symbol.
      # This is kept simple and explicit for clarity and reliability.
      case notification.action
      when 'proof_rejected', 'proof_approved'
        [ApplicationNotificationsMailer, notification.action.to_sym]
      when 'account_created'
        [ApplicationNotificationsMailer, :account_created]
      when /\Amedical_certification_/
        # e.g., 'medical_certification_approved' -> :approved
        [MedicalProviderMailer, notification.action.sub('medical_certification_', '').to_sym]
      # Add other mailer resolutions here.
      else
        Rails.logger.warn "NotificationService: No mailer configured for action: #{notification.action}"
        [nil, nil]
      end
    end

    def handle_delivery_error(notification, error, channel)
      error_message = "NotificationService: Delivery via #{channel} failed for Notification ##{notification.id}: #{error.message}"
      Rails.logger.error error_message

      # Update the notification record to reflect the delivery failure.
      # This is critical for tracking and debugging.
      notification.update_columns(
        delivery_status: 'error',
        metadata: (notification.metadata || {}).merge(
          delivery_error: {
            channel: channel.to_s,
            message: error.message,
            error_at: Time.current.iso8601
          }
        )
      )
    end

    def log_to_audit_trail(notification)
      # The `auditable` polymorphic association links the event directly to the notification.
      Event.create!(
        user: notification.actor || notification.recipient,
        action: "notification_#{notification.action}_sent",
        auditable: notification,
        metadata: {
          notification_id: notification.id,
          recipient_class: notification.recipient.class.name,
          recipient_id: notification.recipient_id,
          channel: notification.metadata['channel'] || 'unknown',
          timestamp: Time.current.iso8601
        }
      )
    rescue StandardError => e
      Rails.logger.error "NotificationService: Audit log creation failed for Notification ##{notification.id}: #{e.message}"
      # We do not re-raise here, as audit logging failure should not prevent notification delivery.
    end
  end
end
